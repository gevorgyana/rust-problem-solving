
                // Let's say we have node {i} from {initial} list, and
                // we have an edge that comes out of {i} and leads to
                // {j}.
                // Is {j} free from malware when we remove the edge
                // {i} -> {j}? Only if the edge is the only one
                // that can spread malware to {j}. In other words, if any
                // {i'} != {i} from {initial} reaches {j} through some
                // edge other than {i} -> {j}, then we cannot assert that
                // {j} is free from malware. To check it, we definitely
                // need O(N^2) time for N BFS traversals, and O(N^2) memory
                // because we are going to maintain a counter for each
                // edge. I am not aware of any way to solve this problem
                // in linear time, and I actually have an argument that
                // makes me think there is no such way. Here it is.

                // T. There is no way to solve this problem in linear time.
                // Here is why. There is no way to answer the following
                // query. Suppose we take some node {i} from the {initial}
                // list. We do not know what sources of malware can reach
                // this node - we can only know if there is a fixed amount
                // nodes that come to the node - say 1, 2, etc. - but we
                // cannot check if all of the nodes in the graph can spread
                // disease to the current node - this would require a
                // traversal of the graph that would take O(N^2) time and
                // memory - as for each node {i} from {initial}, we would
                // need to answer if {i} can reach the current node.
                // We need this structure to answer if we have a way to
                // reach the current node from any {j} from {initial}, such
                // that {i} != {j}. If we do, then removing the edges from
                // {i} to current node will not help because the current
                // node will be infected by someone else.

                // Use this node if every time we visited it, we used the
                // edge {i} -> {next} (except for the trivial loop {i} ->
                // {i}, hence - 1). The following unwraps are guaranteed to
                // work because we have definitely visited direct
                // descendants of {i}.
