use itertools::Itertools;
extern crate serde;

pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.

    for val in graph.iter_mut() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }

    /* SIMULATION for a solution - it works in O(N^2) -  simply
     * try to simulate the spread of malware. It works the same way
     * my initial method does, but uses less memory and it gives the
     * wrong result too with one of the test cases - see
     * https://leetcode.com/problems/minimize-malware-spread-ii/discuss/751440/Why-is-20-expected-in-this-test-case-when-61-gives-the-minimized-value
     */

    // calculate the answer for 20;

    /*
    let mut initial_wo_20: Vec<i32> = initial
        .iter()
        .filter()
        .collect();
     */

    for t in &initial {
        let mut debug_initial =
            initial.clone().into_iter().filter(|e| {
                if *e == *t { false }
                else { true }
            }).collect::<std::collections::vec_deque::VecDeque<i32>>();
        println!("Vec w/o {} {:?}", t, debug_initial);
        let mut debug_initial_counter: i32 = 0;
        let mut vis_debug: std::collections::HashSet::<i32>
            = std::collections::HashSet::new();
        while debug_initial.len() > 0 {
            let current_node = debug_initial.pop_front().unwrap();
            vis_debug.insert(current_node);
            for next in &graph[current_node as usize] {
                if vis_debug.contains(&next) { continue; }
                vis_debug.insert(*next);
                debug_initial.push_back(*next);
                debug_initial_counter += 1;
            }
        }

        println!("The infected nodes w/o {} {}", t, debug_initial_counter);
    }

    // This time we are going to do a full O(N^2) search because the
    // task is indeed complex.

    let mut mem_edge_repeated:
    std::collections::HashMap::<(i32, i32), i32>
        = std::collections::HashMap::new();
    let mut mem_node_repeated:
    std::collections::HashMap::<i32, i32>
        = std::collections::HashMap::new();

    for i in &initial {

        let mut vis_from_i: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        let mut q: std::collections::VecDeque<i32>
            = std::collections::VecDeque::new();
        q.push_back(*i);
        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();
            vis_from_i.insert(current_node);

            mem_node_repeated.insert(
                current_node,
                mem_node_repeated.get(&current_node)
                .unwrap_or(&0) + 1
            );
            for next in &graph[current_node as usize] {
                if vis_from_i.contains(&next) {
                    continue;
                }
                mem_edge_repeated.insert(
                    (current_node, *next),
                    mem_edge_repeated
                        .get(&(current_node, *next))
                        .unwrap_or(&0) + 1
                );
                q.push_back(*next);
                vis_from_i.insert(*next);
            }
        }
    }

    println!("{:?}", mem_node_repeated);
    println!("{:?}", mem_edge_repeated);

    // Then run a similar BFS one more time for each source of malware.
    // As long as the current node can be reached only by the currently
    // selected source of malware, keep BFS going. Update the result
    // as the traversal stops.

    // Note:
    // If there are isolated nodes, they will be counted for every {i}
    // independently, so we can avoid counting them.

    let mut gains: Vec<(i32, i32)> = Vec::new();

    for i in &initial {
        println!("Started working with {}", i);
        let mut q: std::collections::vec_deque::VecDeque<i32>
            = std::collections::vec_deque::VecDeque::new();
        let mut vis: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        q.push_back(*i);
        vis.insert(*i);

        // If the initial node can be reached from nodes other than
        // itself, then it does not count.
        let mut current_gain: i32;
        if *mem_node_repeated.get(&(i)).unwrap() == 1 {
            current_gain = 1;
        } else {
            current_gain = 0;
        }
        println!("Current gain of {} is {}", i, current_gain);

        // These nodes cannot be clean from malware anyway, because
        // we have come to them from an infected node. If they are
        // infected purely by the node that we come from, we mark them
        // as clean again.

        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();
            println!("Current node {}", current_node);
            println!("q {:?}", q);
            for next in &graph[current_node as usize] {

                if vis.contains(&next) {
                    println!("{} is already visited from {}", next, i);
                    continue;
                }

                if *mem_edge_repeated.get(&(current_node, *next))
                   .unwrap() <
                    *mem_node_repeated.get(&next).unwrap() {
                        println!("did not find a bridge");
                        continue;
                    }

                println!("--- found a bridge, continue search with {}", next);
                q.push_back(*next);
                vis.insert(*next);
                current_gain += 1;
            }
            println!("vis {:?}", vis);
        }
        gains.push((*i, current_gain));
    }

    println!("{:?}", gains);

    match gains.iter().max_by(|a, b| {

        let gain = a.1.cmp(&b.1);
        let index = b.0.cmp(&a.0);

        if gain != std::cmp::Ordering::Equal {
            gain
        } else {
            index
        }

    }) {
        Some(max_gain) => {
            max_gain.0
        },

        None => {
            // if it is not possible to decrease the amount of nodes
            // that are infected with malware, then return the first
            // node's index
            *initial.iter().min().unwrap()
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    pub fn custom() {
        // sample graph triangle

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 1], vec![1, 1, 1],
                                        vec![1, 1, 1]];
        let initial: Vec<i32> = vec![0, 1, 2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));


        // not a triangle, but still nothing can be done with this
        // graph, as every node is reachable from at least 2 malware
        // sources
        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0, 1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 0, 0], vec![0, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

    }

    #[test]
    pub fn leetcode() {

        println!("Running Leetcode tests");

        let graph: Vec<Vec<i32>> = vec![vec![1,1,1],
                                        vec![1,1,1],
                                        vec![1,1,1]];
        let initial: Vec<i32> = vec![1,2];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,0,0], vec![0,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,1,0], vec![1,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,1];
        assert_eq!(0,
                   min_malware_spread(graph, initial));
    }

    #[test]
    fn bug() {
        let graph: Vec<Vec<i32>> = vec![vec![1,0,0,0], vec![0,1,0,0],
                                        vec![0,0,1,1], vec![0,0,1,1]];

        let initial: Vec<i32> = vec![3,1];
        assert_eq!(3,
                   min_malware_spread(graph, initial));
    }

    #[test]
    fn final_bug() {
        let t: String
            = std::fs::read_to_string("graph")
            .unwrap()
            .parse()
            .unwrap();

        let graph: Vec<Vec<i32>> = serde_json::from_str(&t)
            .unwrap();

        let t: String
            = std::fs::read_to_string("initial")
            .unwrap()
            .parse()
            .unwrap();

        let initial: Vec<i32> = serde_json::from_str(&t)
            .unwrap();

        assert_eq!(20,
                   min_malware_spread(graph, initial));
    }
}
