use itertools::Itertools;
extern crate serde;

pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.
/*
    for val in graph.iter_mut() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }
*/
    // O(N^2) time complexity: count how many times each edge and node
    // was used during the spread of malware, if we do not remove
    // anything at all. The alternative approach is to try to simulate
    // malware spread from each node and pick the one that has the
    // least number of infected nodes. To see the alternative
    // implementation, go up one directory.

    // Gotcha 1: add all the initial nodes to the {vis} cached right
    // when we add them at the very beginning, the difference between
    // this task and {malware-spread} is that here we start the BFS
    // from multiple sources at once to calculate the values that are
    // described above.

    // Gotcha 2: if a node is removed from the list, then it MEANS THAT
    // we a) cannot get to it from any other node, b) cannot move from
    // it to any other node. This means that we must just forget and
    // ignore it completely! My initial understanding was that we can
    // still get to it as a result of malware spread, but after reading
    // the two versions of the problem again it makes more sense.
/*
    let mut mem_edge_repeated:
    std::collections::HashMap::<(i32, i32), i32>
        = std::collections::HashMap::new();
    let mut mem_node_repeated:
    std::collections::HashMap::<i32, i32>
        = std::collections::HashMap::new();
*/
    // This solution required N^2 to preprocess the graph with N BFS
    // traversals and then N^2 to examine select the best answer with
    // another BFS.

    // This series of BFS does not care about the removed values
/*
    for i in &initial {
        let mut vis_from_i: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        let mut q: std::collections::VecDeque<i32>
            = std::collections::VecDeque::new();
        q.push_back(*i);
        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();

            // prevents from visitng loops (from {i} to {i})
            vis_from_i.insert(current_node);

            mem_node_repeated.insert(
                current_node,
                mem_node_repeated.get(&current_node)
                .unwrap_or(&0) + 1
            );
            for next in &graph[current_node as usize] {
                if vis_from_i.contains(&next) {
                    continue;
                }
                mem_edge_repeated.insert(
                    (current_node, *next),
                    mem_edge_repeated
                        .get(&(current_node, *next))
                        .unwrap_or(&0) + 1
                );
                q.push_back(*next);
                vis_from_i.insert(*next);
            }
        }
    }
*/
/*
    println!("{:?}", mem_node_repeated);
    println!("{:?}", mem_edge_repeated);
*/
    // Run a similar BFS one more time for each source of malware.
    // As long as the current node can be reached only by the currently
    // selected source of malware, keep BFS going. See the longer
    // explanation to understand why this works. Update the result
    // as the traversal stops.

    // Please pay attention to isolated nodes. They are not reached by
    // the malware spread and therefore are never counted, which is
    // okay.
/*
    let mut gains: Vec<(i32, i32)> = Vec::new();
*/
    // In this problem, it is not possible to start from some node and
    // work until we stop from it, as the node itself as well as any
    // edge coming from it to some other node are removed! Therefore
    // we need to try and possibly optimize selecting the best value to
    // remove and actually removing it, and starting BFS from other
    // nodes from {initial}.

    // The trick with calculating the edges and nodes and how many
    // times they repeas is for answering the query: is a node visited
    // by more than one edge? if so, then there still might be a
    // problem: it is visited by the same infected node from different
    // edges -> NOPE this is not possible, because BFS does not repeat
    // nodes in traversal! So how do we know that we visited the node
    // from some other node, which means there was some other malware
    // spread source that reached this value? check if the node counter
    // is greater than the edge counter -> then we must have visited
    // the node from some other malware source, other than the one
    // that was used for the edge.
    //
    // The problem is that we do not know if we used the forbidden
    // edges to get to the node anyway.... So the information from
    // counters is not enough.

    // Suppose we start from one node and see how much it covers
    // independently - we can't do that because we cannot even start
    // from anywhere! Therefore we only can do the following - start
    // malware spread from the malwared values - and if we do that,
    // then we have no reason to do anything more compilcated than
    // doing N BFS searches and updating the answer.

    // What if we still want to use the counters? We would need to
    // recount the values and then - on a good graph - do the trick
    // described above. Indeed, on a correct graph, we would check each
    // (O(N)) initial node, remove it and then start a search from it,
    // (O(N)), then look at the node counter - and the edge counter -
    // if they are the same (no loops are allowed) - then we must have
    // found the bridge - nobody else visited this node from us? we are
    // not sure, because the bridge could be used multiple times.
    // then but if it was used multiple times, then it was used by
    // multiple sources of malware - because BFS only visits each edge
    // and node it visits ONCE. so we could say that there is some
    // other node that visits it. if so, we would not count the value
    // as solely independant. if the edge had a counter less than
    // the node - then somebody else must have visited this node. so
    // we could just check for the node value - if it was used only
    // once - then it is counted. So we do not even need the edge
    // counters... Just node counters.

    // The differentce between this problem and the easier one is
    // that this one is searching on N graphs, and the previous one
    // is searching inside one graph.
/*
    for i in &initial {
        println!("Removing and calculating the answer {}", i);
        let mut q: std::collections::vec_deque::VecDeque<i32>
            = std::collections::vec_deque::VecDeque::new();
        let mut vis: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        let current_gain: i32 = 0;

        // a loop to itself can happen, but it is not allowed, as {i}
        // is excluded from the graph completely
        for next in &graph[*i as usize] {
            if *next != *i {
                q.push_back(*next);
            }
        }

        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();
            vis.insert(current_node);
            for next in &graph[current_node as usize] {
                if vis.contains(next) || *next == *i {
                    continue;
                }
                vis.insert(*next);
                q.push_back(*next);
            }
        }
        gains.push((*i, current_gain));
    }

    println!("{:?}", gains);

    match gains.iter().min_by(|a, b| {

        let gain = a.1.cmp(&b.1);
        let index = a.0.cmp(&b.0);

        if gain != std::cmp::Ordering::Equal {
            gain
        } else {
            index
        }

    }) {
        Some(max_gain) => {
            max_gain.0
        },

        None => {
            // if it is not possible to decrease the amount of nodes
            // that are infected with malware, then return the first
            // node's index
            *initial.iter().min().unwrap()
        }
    }
     */

    1
}

fn main() {

}
