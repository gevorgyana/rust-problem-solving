use std::{thread, time};

pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // let debug_time = time::Duration::from_secs(0);

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.

    for val in graph.iter_mut() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }

    // Build a cache that would answer, for a given node, what sources
    // can spread malware to this node. This must be done in O(N) via
    // BFS.

    // -1 means there is no single way to reach the node from any given
    // source; otherwise a non-negative number indicates the node
    let mut mal_spread_dep: std::collections::HashMap<i32, i32> =
        std::collections::HashMap::new();

    for i in &initial {

        // println!("New i iter\n");
        // thread::sleep(debug_time);


        /*println!("The global cache looks like this {:?}",
                 mal_spread_dep);
         */

        if mal_spread_dep.contains_key(&i) {
            // println!("Invalidate - sb already reached it {}", i);
            &mal_spread_dep.insert(*i, -1);
        } else {
            /*println!("Initialize the cache with current malware source");
            &mal_spread_dep.insert(*i, *i);
             */
        }

        let mut vis_from_i: std::collections::HashSet<i32> =
            std::collections::HashSet::new();
        let mut q: Vec<i32> = vec![*i];

        // this is quadratic
        while q.len() > 0 {
            //println!("loop1");
            // register current node
            let current_node_: Vec<i32> =
                q.drain(0..1).collect();
            let current_node: i32 = current_node_[0];
            //println!("{} cached visit", current_node);
            // vis_from_i.insert(current_node);

            //println!("Just visited {}", current_node);

            /*println!("Going to visit all neighbors of {}, here they
are {:?}",
                     current_node, &graph[current_node as usize]);
             */

            for next in &graph[current_node as usize] {

                // thread::sleep(debug_time);

                //println!("Next to {} is {}", current_node, next);

                // already seen this value from this malware source,
                // we are not supposed to be here, so stop immediately
                if vis_from_i.contains(&next) {
                    //println!("Skipping {} because we already visited it from {}", next, *i);
                    continue;
                }

                // we have seen this value from another malware source,
                // so invalidate this node
                if mal_spread_dep.contains_key(&next) {
                    if *mal_spread_dep.get(&next).unwrap() != *i {
                        //println!("Invalidate {}", next);
                        mal_spread_dep.insert(*next, -1);
                        /*println!("The global cache looks like this {:?}",
                                 mal_spread_dep);
                         */
                    } else {
                        //println!("Doing nothing");
                        /*println!("The global cache looks like this {:?}",
                                 mal_spread_dep);
                         */
                    }
                }

                // else we are the first ones to reach it, mark it
                else {
                    /*println!("First to reach {} is malware source {} ",
                             next, *i);
                     */
                    mal_spread_dep.insert(*next, *i);
                    /*println!("The global cache looks like this {:?}",
                             mal_spread_dep);
                     */
                }

                //println!("Pushing {}", *next);
                //println!("vis cache before pushing {:?}", vis_from_i);
                //println!("queue before pushing {:?}", q);

                vis_from_i.insert(*next);
                q.push(*next);

            }
        }
    }

    for i in 0..graph.len() {
        match mal_spread_dep.get(&(i as i32)) {
            Some(value) => {
                println!("{} belongs to {}", i, value);
            },
            None => {
                println!("{} not visited", i);
            },
        }
    }

    // println!("---");

    // Then run a similar BFS one more time for each source of malware.
    // As long as the current node can be reached only by the currently
    // selected source of malware, keep BFS going. Update the result
    // as the traversal stops.

    // If there are isolated nodes, they will be counter for every i
    // independently, so we can avoid calculating them.

    let mut gains: Vec<(i32, i32)> = Vec::new();

    for i in &initial {

        println!("Started working with {}", i);

        let mut q: std::collections::vec_deque::VecDeque<i32>
            = std::collections::vec_deque::VecDeque::new();
        let mut vis: std::collections::HashSet<i32>
            = std::collections::HashSet::new();

        // If the initial node is initially dirty (it can be reached
        // from nodes other than the i-th node), then it does not
        // count.

        let mut current_gain: i32;
        if mal_spread_dep.get(&i) != Some(i) {
            current_gain = 0;
        } else {
            current_gain = 1;
        }

        // We give these guys a second chance, by removing the parental
        // relationships from the selected source of malware to them.

        for next in &graph[*i as usize] {

            // Let's say we have node {i} from {initial} list, and we
            // have an edge that comes out of {i} and leans to {j}.
            // Is {j} free from malware when we remove the the edge
            // coming from {i} to {j}? Only if the edge is the only one
            // that can spread malware to {j}. In other words, if any
            // {i'} != {i} from {initial} reaches {j} through some
            // edge other than {i} -> {j}, then we cannot assert that
            // {j} is free from malware. To check it, we definitely
            // need O(N^2) time for N BFS traversals, and O(N^2) memory
            // because we are going to maintain a counter for each
            // edge. I am not aware of any way to solve this problem
            // in linear time, and I actually have an argument that
            // makes me think there is no such way. Here it is.

            // T. There is no way to solve this problem in linear time.
            // Here is why. There is no way to answer the following
            // query. Suppose we take some node {i} from the {initial}
            // list. We do not know what sources of malware can reach
            // this node - we can only know if there is a fixed amount
            // nodes that come to the node - say 1, 2, etc. - but we
            // cannot check if all of the nodes in the graph can spread
            // disease to the current node - this would require a
            // traversal of the graph that would take O(N^2) time and
            // memory - as for each node {i} from {initial}, we would
            // need to answer if {i} can reach the current node.
            // We need this structure to answer if we have a way to
            // reach the current node from any {j} from {initial}, such
            // that {i} != {j}. If we do, then removing the edges from
            // {i} to current node will not help because the current
            // node will be infected by someone else.

            if mal_spread_dep.get(&next) != Some(i) {
                continue;
            }

            println!("next in {:?} is {}", &graph[*i as usize], next);
            q.push_back(*next);
            vis.insert(*next);
            current_gain += 1;
        }

        while q.len() > 0 {
            println!("loop2");
            let current_node = q.pop_front().unwrap();
            println!("The queue after we took the front value {:?}",
                     q);
            println!("Visiting neighbors of {} from malware source {}",
                     current_node, i);

            for next in &graph[current_node as usize] {
                if mal_spread_dep.get(&next) == Some(i) &&
                    !vis.contains(&next) {
                        println!("Pushing {} to the queue", next);
                        q.push_back(*next);
                        vis.insert(*next);
                        current_gain += 1;
                    }
            }
        }

        gains.push((*i, current_gain));
    }

    println!("{:?}", gains);

    match gains.iter().max_by(|a, b| {

        let gain = a.1.cmp(&b.1);
        let index = b.0.cmp(&a.0);

        if gain != std::cmp::Ordering::Equal {
            gain
        } else {
            index
        }

    }) {
        Some(max_gain) => {
            max_gain.0
        },

        None => {
            // if it is not possible to decrease the amount of nodes
            // that are infected with malware, then return the first
            // node's index
            *initial.iter().min().unwrap()
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    pub fn custom() {
        // sample graph triangle
        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 1], vec![1, 1, 1],
                                        vec![1, 1, 1]];
        let initial: Vec<i32> = vec![0, 1, 2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        // not a triangle, but still nothing can be done with this
        // graph, as every node is reachable from at least 2 malware
        // sources

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0, 1];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 0, 0], vec![0, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![0, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));
    }

    #[test]
    pub fn leetcode() {

        //println!("Running Leetcode tests");

        let graph: Vec<Vec<i32>> = vec![vec![1,1,1], vec![1,1,1],
                                        vec![1,1,1]];
        let initial: Vec<i32> = vec![1,2];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,0,0], vec![0,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,1,0], vec![1,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,1];
        assert_eq!(0,
                   min_malware_spread(graph, initial));
    }
/*
    #[test]
    fn bug() {
        let graph: Vec<Vec<i32>> = vec![vec![1,0,0,0], vec![0,1,0,0],
                                        vec![0,0,1,1], vec![0,0,1,1]];

        let initial: Vec<i32> = vec![3,1];
        assert_eq!(3,
                   min_malware_spread(graph, initial));
        // ---
        let graph: Vec<Vec<i32>> = vec![vec![1,1,0], vec![1,1,1],
                                        vec![0,1,1]];

        let initial: Vec<i32> = vec![0,1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));
    }
     */
    /*
    #[test]
    fn loops() {
        let t: String
            = std::fs::read_to_string("graph")
            .unwrap()
            .parse()
            .unwrap();

        let graph: Vec<Vec<i32>> = serde_json::from_str(&t)
            .unwrap();

        let t: String
            = std::fs::read_to_string("initial")
            .unwrap()
            .parse()
            .unwrap();

        let initial: Vec<i32> = serde_json::from_str(&t)
            .unwrap();

        assert_eq!(3,
                   min_malware_spread(graph, initial));
    }
     */
}

fn build_new_represetnation(mut graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        // This time we are going to do a full O(N^2) search because the
    // task is indeed complex.

    let mut mem_edge_repeated:
    std::collections::HashMap::<(i32, i32), i32>
        = std::collections::HashMap::new();
    let mut mem_node_repeated:
    std::collections::HashMap::<i32, i32>
        = std::collections::HashMap::new();

    for i in &initial {
        let mut vis_from_i: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        let mut q: std::collections::VecDeque<i32>
            = std::collections::VecDeque::new();
        q.push_back(*i);

        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();

            mem_node_repeated.insert(
                current_node,
                mem_node_repeated.get(&current_node).unwrap_or(&1) + 1
            );

            for next in &graph[current_node as usize] {
                if vis_from_i.contains(&next) {
                    continue;
                }

                mem_edge_repeated.insert(
                    (current_node, *next),
                    mem_edge_repeated
                        .get(&(current_node, *next))
                        .unwrap_or(&1) + 1
                );

                q.push_back(*next);
                vis_from_i.insert(*next);
            }
        }
    }

    for i in 0..graph.len() {
        println!("{}", i);
        let mut q: std::collections::VecDeque<i32>
            = std::collections::VecDeque::<i32>::new();
        let mut vis_from_i: std::collections::HashSet::<i32>
            = std::collections::HashSet::<i32>::new();
        q.push_back(i as i32);
        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();
            println!("Node {} visited this many times {}",
                     current_node,
                     mem_node_repeated.get(&current_node).unwrap()
            );
            for next in &graph[current_node as usize] {
                if vis_from_i.contains(next) {
                    continue;
                }
                q.push_back(*next);
                vis_from_i.insert(*next);
                println!("Edge {:?} visited this many times {}",
                         (current_node, *next),
                         mem_edge_repeated
                         .get(&(current_node, *next)).unwrap());
            }
        }
    }

    1
}
