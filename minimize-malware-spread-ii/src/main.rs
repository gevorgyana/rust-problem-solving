use std::{thread, time};

extern crate serde;

pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // let debug_time = time::Duration::from_secs(0);

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.

    for val in graph.iter_mut() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }

    // This time we are going to do a full O(N^2) search because the
    // task is indeed complex.

    let mut mem_edge_repeated:
    std::collections::HashMap::<(i32, i32), i32>
        = std::collections::HashMap::new();
    let mut mem_node_repeated:
    std::collections::HashMap::<i32, i32>
        = std::collections::HashMap::new();

    for i in &initial {

        let mut vis_from_i: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        let mut q: std::collections::VecDeque<i32>
            = std::collections::VecDeque::new();
        q.push_back(*i);

        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();

            mem_node_repeated.insert(
                current_node,
                mem_node_repeated.get(&current_node)
                .unwrap_or(&0) + 1
            );

            for next in &graph[current_node as usize] {
                if vis_from_i.contains(&next) {
                    continue;
                }

                mem_edge_repeated.insert(
                    (current_node, *next),
                    mem_edge_repeated
                        .get(&(current_node, *next))
                        .unwrap_or(&0) + 1
                );

                q.push_back(*next);
                vis_from_i.insert(*next);
            }
        }
    }

    // Then run a similar BFS one more time for each source of malware.
    // As long as the current node can be reached only by the currently
    // selected source of malware, keep BFS going. Update the result
    // as the traversal stops.

    // Note:
    // If there are isolated nodes, they will be counter for every i
    // independently, so we can avoid counting them.

    let mut gains: Vec<(i32, i32)> = Vec::new();

    println!("{:?}", initial);

    for i in &initial {
        println!("Started working with {}", i);
        let mut q: std::collections::vec_deque::VecDeque<i32>
            = std::collections::vec_deque::VecDeque::new();
        let mut vis: std::collections::HashSet<i32>
            = std::collections::HashSet::new();
        vis.insert(*i);
        q.push_back(*i);

        // If the initial node is dirty (it can be reached from nodes
        // other than the i-th node), then it does not count. It is
        // dirty if it was used in BFS and its counter is > 1 (1 is for
        // the trivial case of edge {i} -> {i}).
        let mut current_gain: i32;
        if *mem_node_repeated.get(&(i)).unwrap() == 1 {
            current_gain = 1;
        } else {
            current_gain = 0;
        }

        println!("Current gain of {} is {}", i, current_gain);

        // These nodes cannot be clean from malware anyway, because
        // we have come to them from an infected node. If they are
        // infected purely by the node that we come from, we mark them
        // as clean again.

        while q.len() > 0 {
            let current_node = q.pop_front().unwrap();
            println!("{:?}", q);
            for next in &graph[current_node as usize] {

                if vis.contains(&next) {
                    continue;
                }
                vis.insert(*next);

                if *mem_edge_repeated.get(&(current_node, *next))
                   .unwrap() <
                    *mem_node_repeated.get(&next).unwrap() - 1 {
                    println!("did not find a bridge");
                    continue;
                }
                println!("--- We found a bridge");
                q.push_back(*next);
                current_gain += 1;
            }
            println!("{:?}", vis);
        }
        gains.push((*i, current_gain));
    }

    println!("{:?}", gains);

    match gains.iter().max_by(|a, b| {

        let gain = a.1.cmp(&b.1);
        let index = b.0.cmp(&a.0);

        if gain != std::cmp::Ordering::Equal {
            gain
        } else {
            index
        }

    }) {
        Some(max_gain) => {
            max_gain.0
        },

        None => {
            // if it is not possible to decrease the amount of nodes
            // that are infected with malware, then return the first
            // node's index
            *initial.iter().min().unwrap()
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    pub fn custom() {
        // sample graph triangle

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 1], vec![1, 1, 1],
                                        vec![1, 1, 1]];
        let initial: Vec<i32> = vec![0, 1, 2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        // not a triangle, but still nothing can be done with this
        // graph, as every node is reachable from at least 2 malware
        // sources

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0, 1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 0, 0], vec![0, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));
    }

    #[test]
    pub fn leetcode() {

        //println!("Running Leetcode tests");

        let graph: Vec<Vec<i32>> = vec![vec![1,1,1], vec![1,1,1],
                                        vec![1,1,1]];
        let initial: Vec<i32> = vec![1,2];
        assert_eq!(1,
                   min_malware_spread(graph, initial));
/*
        let graph: Vec<Vec<i32>> = vec![vec![1,0,0], vec![0,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,1,0], vec![1,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,1];
        assert_eq!(0,
                   min_malware_spread(graph, initial));
*/
    }

    #[test]
    fn bug() {
        let graph: Vec<Vec<i32>> = vec![vec![1,0,0,0], vec![0,1,0,0],
                                        vec![0,0,1,1], vec![0,0,1,1]];

        let initial: Vec<i32> = vec![3,1];
        assert_eq!(3,
                   min_malware_spread(graph, initial));
    }

    #[test]
    fn final_bug() {
        let t: String
            = std::fs::read_to_string("graph")
            .unwrap()
            .parse()
            .unwrap();

        let graph: Vec<Vec<i32>> = serde_json::from_str(&t)
            .unwrap();

        let t: String
            = std::fs::read_to_string("initial")
            .unwrap()
            .parse()
            .unwrap();

        let initial: Vec<i32> = serde_json::from_str(&t)
            .unwrap();

        assert_eq!(32,
                   min_malware_spread(graph, initial));
    }
}
