pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.

    for val in graph.iter_mut() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }

    /* SIMULATION for a solution - it works in O(N^2) -  simply
     * try to simulate the spread of malware. It works the same way
     * my initial method does, but uses less memory and it gives the
     * wrong result too with one of the test cases - see
     * https://leetcode.com/problems/minimize-malware-spread-ii/discuss/751440/Why-is-20-expected-in-this-test-case-when-61-gives-the-minimized-value

     * there was a problem with my previous approach - it would not work
     * because with my solution the nodes removed from the initial list
     * were still available to come into, even though they were not
     * available to move from. That could give a fake +1 to some of
     * the solutions.
     */

    let mut answer_val: i32 = i32::max_value();
    let mut answer_index: i32 = i32::max_value();
    let mut gains: Vec<(i32, i32)> = Vec::new();

    for t in &initial {
        let mut debug_initial =
            initial.clone().into_iter().filter(|e| {
                if *e == *t { false }
                else { true }
            }).collect::<std::collections::vec_deque::VecDeque<i32>>();
        println!("started {}", *t);
        let mut debug_initial_counter: i32 = initial.len() as i32;
        let mut vis_debug: std::collections::HashSet::<i32>
            = std::collections::HashSet::new();
        for ini in &initial {
            vis_debug.insert(*ini);
        }
        while debug_initial.len() > 0 {
            let current_node = debug_initial.pop_front().unwrap();
            println!("{}", current_node);
            vis_debug.insert(current_node);
            /*
            if *t == current_node {
                // this can never happen thanks to the fact that we
                // removed the node {t} from the initial nodes in the
                // queue and also due to the check below
                assert_eq!(false, true);
                continue; }
             */
            for next in &graph[current_node as usize] {
                if vis_debug.contains(&next) { continue; }
                if *t == *next {
                    // println!("Cannot move to a non-existing node");
                    continue;
                }
                vis_debug.insert(*next);
                debug_initial.push_back(*next);
                debug_initial_counter += 1;
            }
        }
        gains.push((*t, debug_initial_counter));
    }

    match gains.iter().min_by(|a, b| {

        let index = a.0.cmp(&b.0);
        let gain = a.1.cmp(&b.1);

        if gain != std::cmp::Ordering::Equal {
            gain
        } else {
            index
        }

    }) {
        Some(max_gain) => {
            max_gain.0
        },
        None => {
            // if it is not possible to decrease the amount of nodes
            // that are infected with malware, then return the first
            // node's index
            *initial.iter().min().unwrap()
        }
    }
}
