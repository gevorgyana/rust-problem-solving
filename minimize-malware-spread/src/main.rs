use std::{thread, time};
// there is a bottleneck somewhere here? or a loop?
pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // let debug_time = time::Duration::from_secs(0);

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.

    for val in graph.iter_mut() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }

    // Build a cache that would answer, for a given node, what sources
    // can spread malware to this node. This must be done in O(N) via
    // BFS.

    // -1 means there is no single way to reach the node from any given
    // source; otherwise a non-negative number indicates the node
    let mut mal_spread_dep: std::collections::HashMap<i32, i32> =
        std::collections::HashMap::new();

    for i in &initial {

        // println!("New i iter\n");
        // thread::sleep(debug_time);

        /*
        println!("The global cache looks like this {:?}",
                 mal_spread_dep);
         */

        if mal_spread_dep.contains_key(&i) {
            // println!("Invalidate - sb already reached it {}", i);
            &mal_spread_dep.insert(*i, -1);
        } else {
            /*
            println!("Initialize the cache with current malware source");*/
            &mal_spread_dep.insert(*i, *i);
        }

        let mut vis_from_i: std::collections::HashSet<i32> =
            std::collections::HashSet::new();
        let mut q: Vec<i32> = vec![*i];

        while q.len() > 0 {

            // println!("Queue currently looks like this {:?}", q);
            // thread::sleep(debug_time);

            // register current node
            let current_node_: Vec<i32> =
                q.drain(0..1).collect();
            let current_node: i32 = current_node_[0];
            vis_from_i.insert(current_node);

            // println!("Just visited {}", current_node);

            /*
            println!("Going to visit all neighbors of {}, here they
are {:?}",
                     current_node, &graph[current_node as usize]);
             */

            for next in &graph[current_node as usize] {

                // thread::sleep(debug_time);

                // println!("Next to {} is {}", current_node, next);

                // already seen this value from this malware source,
                // we are not supposed to be here, so stop immediately
                if vis_from_i.contains(&next) {
                    /*
                    println!("Skipping {} because we already visited it from {}", next, *i);
                     */
                    continue;
                }

                // we have seen this value from another malware source,
                // so invalidate this node
                if mal_spread_dep.contains_key(&next) {
                    if *mal_spread_dep.get(&next).unwrap() != *i {
                        // println!("Invalidate {}", next);
                        mal_spread_dep.insert(*next, -1);

                        /*
                        println!("The global cache looks like this {:?}",
                                 mal_spread_dep);
                         */
                    } else {
                        // println!("Doing nothing");
                        /*
                        println!("The global cache looks like this {:?}",
                                 mal_spread_dep);
                         */
                    }
                }

                // else we are the first ones to reach it, mark it
                else {
                    /*
                    println!("First to reach {} is malware source {} ",
                             next, *i);
                     */
                    mal_spread_dep.insert(*next, *i);
                    /*
                    println!("The global cache looks like this {:?}",
                             mal_spread_dep);
                     */
                }

                // println!("Pushing {}", *next);
                q.push(*next);
            }
        }
    }

    for i in 0..graph.len() {
        match mal_spread_dep.get(&(i as i32)) {
            Some(value) => {
                // println!("{} belongs to {}", i, value);
            },
            None => {
                // println!("{} not visited", i);
            },
        }
    }

    // Then run a similar BFS one more time for each source of malware.
    // As long as the current node can be reached only by the currently
    // selected source of malware, keep BFS going. Update the result
    // as the traversal stops.

    // println!("---");

    let mut gains: Vec<(i32, i32)> = Vec::new();

    for i in &initial {

        if *mal_spread_dep.get(i).unwrap() == -1 {
            continue;
        }

        // println!("Started working with {}", i);

        let mut q: std::collections::vec_deque::VecDeque<i32>
            = std::collections::vec_deque::VecDeque::new();
        let mut vis: std::collections::HashSet<i32>
            = std::collections::HashSet::new();

        q.push_back(*i);
        vis.insert(*i);

        // if we are here, then we have checked the initial node,
        // therefore we start from one, not zero
        let mut current_gain: i32 = 1;

        while q.len() > 0 {

            let current_node = q.pop_front().unwrap();

            /*
            println!("The queue after we took the front value {:?}",
                     q);
            println!("Visiting neighbors of {} from malware source {}",
                     current_node, i);
             */

            for next in &graph[current_node as usize] {
                if mal_spread_dep.get(&next) == Some(i) &&
                    !vis.contains(&next) {
                        // println!("Pushing {} to the queue", next);
                        q.push_back(*next);
                        vis.insert(*next);
                        current_gain += 1;
                    }
            }
        }

        gains.push((*i, current_gain));
    }

    println!("{:?}", gains);

    match gains.iter().max_by(|a, b| {

        let gain = a.1.cmp(&b.1);
        let index = b.0.cmp(&a.0);

        if gain != std::cmp::Ordering::Equal {
            gain
        } else {
            index
        }

    }) {
        Some(max_gain) => {
            max_gain.0
        },

        None => {
            // if it is not possible to decrease the amount of nodes
            // that are infected with malware, then return the first
            // node's index
            *initial.iter().min().unwrap()
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn custom() {
        // sample graph triangle
        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 1], vec![1, 1, 1],
                                        vec![1, 1, 1]];
        let initial: Vec<i32> = vec![0, 1, 2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        // not a triangle, but still nothing can be done with this
        // graph, as every node is reachable from at least 2 malware
        // sources
        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0, 1];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![1, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![0];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 0, 0], vec![0, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1, 1, 0], vec![0, 1, 1],
                                        vec![0, 1, 1]];
        let initial: Vec<i32> = vec![1];
        assert_eq!(1,
                   min_malware_spread(graph, initial));
    }

    #[test]
    fn leetcode() {

        println!("Running Leetcode tests");

        let graph: Vec<Vec<i32>> = vec![vec![1,1,1], vec![1,1,1],
                                        vec![1,1,1]];
        let initial: Vec<i32> = vec![1,2];
        assert_eq!(1,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,0,0], vec![0,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,2];
        assert_eq!(0,
                   min_malware_spread(graph, initial));

        let graph: Vec<Vec<i32>> = vec![vec![1,1,0], vec![1,1,0],
                                        vec![0,0,1]];
        let initial: Vec<i32> = vec![0,1];
        assert_eq!(0,
                   min_malware_spread(graph, initial));
    }

    #[test]
    fn bug() {
        let graph: Vec<Vec<i32>> = vec![vec![1,0,0,0], vec![0,1,0,0],
                                        vec![0,0,1,1], vec![0,0,1,1]];
        let initial: Vec<i32> = vec![3,1];
        assert_eq!(3,
                   min_malware_spread(graph, initial));
    }
}
