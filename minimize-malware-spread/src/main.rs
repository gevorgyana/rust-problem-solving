use std::{thread, time};

pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>)
                          -> i32 {

    // First, convert the graph list into a more convenient
    // representation. For each gr[i], remove all the zeros and leave
    // only the i32 values indicating the nodes being connected.

    for (i, mut val) in graph.iter_mut().enumerate() {
        val.reserve(val.len());
        let mut filtered: Vec<i32> = Vec::new();
        for (j, mut inner_val) in val.iter_mut().enumerate() {
            if *inner_val == 1 {
                println!("Minor check {}", j);
                filtered.push(j as i32); }
        }
        val.drain(0..val.len());
        val.append(&mut filtered);
    }

    for i in &graph {
        println!("{:?}", i);
    }

    let debug_time = time::Duration::from_secs(1);

    // Build a cache that would answer, for a given node, what sources
    // can spread malware to this node. This must be done in O(N) via
    // BFS.

    // -1 means there is no single way to reach the node from any given
    // source; otherwise a non-negative number indicates the node
    let mut mal_spread_dep: std::collections::HashMap<i32, i32> =
        std::collections::HashMap::new();

    for i in initial {

        println!("New i iter");
        thread::sleep(debug_time);

        let mut vis_from_i: std::collections::HashSet<i32> =
            std::collections::HashSet::new();
        let mut q: Vec<i32> = vec![i];

        while q.len() > 0 {

            println!("This is a new q iter");
            thread::sleep(debug_time);
            let current_node: i32 = q.pop().unwrap();
            vis_from_i.insert(current_node);
            println!("{:?}", q);

            for next in &graph[current_node as usize] {

                println!("Working with next val {}", next);

                /*
                if vis_from_i.contains(&next) {
                    continue;
                }

                // work with the global cache
                match mal_spread_dep.get(&current_node) {
                    Some(value) => {
                        println!("Some {} with {}", value,
                                 current_node);
                        if *value != i {
                            mal_spread_dep.insert(current_node, -1);
                        }
                    }
                    None => {
                        println!("None with {}", current_node);
                        mal_spread_dep.insert(current_node, i);
                    }
                }
                q.push(*next);
                 */
            }
        }
    }

    for i in 0..graph.len() {
        match mal_spread_dep.get(&(i as i32)) {
            Some(value) => {
                println!("{} belongs to {}", value, i);
            },
            None => {
                println!("{} not visited", i);
            },
        }
    }

    // Then run a similar BFS one more time for each source of malware.
    // As long as the current node can be reached only by the currently
    // selected source of malware, keep BFS going. Update the result
    // as the traversal stops.

    1
}

fn main() {
    // sample graph triangle
    let graph: Vec<Vec<i32>> = vec![vec![1, 1, 1], vec![1, 1, 1],
                                    vec![1, 1, 1]];
    let initial: Vec<i32> = vec![0, 1, 2];
    assert_eq!(1,
               min_malware_spread(graph, initial));

}
